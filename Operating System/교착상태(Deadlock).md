# 교착상태(Deadlock)

![출처) [https://velog.io/@dltmdrl1244/운영체제-Ch07-교착상태-Deadlock](https://velog.io/@dltmdrl1244/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch07-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-Deadlock)](images/os02171.png)

출처) [https://velog.io/@dltmdrl1244/운영체제-Ch07-교착상태-Deadlock](https://velog.io/@dltmdrl1244/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch07-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-Deadlock)

### 교착상태(Deadlock)란?

- 일어나지 않을 사건을 기다리며 무한히 대기하는 현상을 의미
- 자원을 소유한 스레드들 사이에서 서로가 다른 스레드의 자원을 요청하여 모든 스레드가 무한정 대기하는 현상

### 컴퓨터 시스템에 잠재된 교착상태 유발 요인

- **자원** : 교착상태는 멀티스레드가 자원을 동시에 사용하려는 충돌에서 발생
- **자원과 스레드** : 한 스레드가 동시에 여러 개의 자원을 필요로 하는 경우가 있다.
- **자원과 운영체제** : 운영체제는 한 번에 하나씩 자원을 할당한다.
- **자원 비선점** : 할당된 자원은 스레드가 자발적으로 내놓기 전에 강제로 뺐지 못한다.

### 교착상태 발생 4가지 필요충분조건(Coffman condition)

1. **상호 배제(Mutual exclusion)** : 자원을 한 번에 한 스레드에게만 할당
2. **점유 대기(Hold and wait)** : 스레드가 자원을 소유하면서 다른 자원 대기
3. **비선점(비선점, No preemption)** : 스레드에게 할당된 자원을 강제로 빼앗지 못함
4. **순환 대기(Circular wait)** : 한 그룹의 스레드들에서 각 스레드가 다른 스레드가 소유한 자원을 요청하는 환형 고리 형성

    <U>**4가지 조건 중 한 가지라도 성립하지 않게 하면 교착상태에 빠지지 않는다.**</U>

### 교착상태 해결 방법

- 교착상태 예방
- 교착상태 회피
- 교착상태 감지 및 복구
- **교착상태 무시**

### 교착상태 예방

코프만 4조건 중 최소 한 가지 이상 성립하지 못하게 하여 교착상태 예방

**시스템 처리량이나 자원 사용의 효율성을 떨어트리는 단점이있다.**

1. **상호배제 없애기** : 2개 이상의 스레드가 동시에 자원을 사용할 수 있도록 허용 → 근본적으로 불가능하다. ex) 하나의 프린터를 2개의 스레드가 동시에 사용하면 출력물이 엉망이 된다.)
2. **소유하면서 대기 부정** : 스레드가 필요한 자원을 처음부터 모두 가지게 한다. 할당 불가능할 경우 스레드 실행 대기 OR 스레드가 자원을 소유한 상태에서 새로운 자원이 필요하게 되면, 현재 할당받은 자원을 모두 반환하고 필요한 모든 자원을 한꺼번에 요청
3. **자원의 선점 허용** : 더 높은 우선순위 스레드가 자원 요청하면 우선순위가 낮은 스레드로부터 자원을 빼앗는다. → 강제로 자원을 반환한 스레드의 이전 상태를 관리해야 하여 단순치 않은 방법
4. **순환성 대기 제거** : 모든 스레드가 번호순으로 자원을 할당받으면 순환성 대기가 발생하지 않는다.

### 교착상태 회피

자원할당 알고리즘을 이용하여 교착상태를 방지하는 방법

자원할당을 요청받았을 때 환형대기가 발생하지 않는다는 확신이 서는 경우에만 자원을 할당함으로써 교착상태의 발생을 피한다.

**자원을 할당할 때마다 교착상태의 발생 가능성을 검사하므로 시스템 성능 저하**

- **은행원 알고리즘**
    - 시스템을 안전한 상태와 불안전한 상태로 나누고, 자원을 할당하였을 때 안정한 상태로 갈 때만 자원을 할당
    - 각 스레드가 필요로하는 자원의 개수, 현재 실행중인 각 스레드가 할당 받은 자원의 개수, 그리고 시스템 내 할당 가능한 자원의 개수를 토대로 현재 요청된 자원을 할당해도 안전할 지 판단
    - 실행 전 필요한 자원의 수를 운영체제에 알려줘야 하는데, 스레드의 실행 전에 필요한 자원의 개수를 아는 것은 사실상 불가능, 실행 중인 스레드의 개수도 동적으로 변하기 때문에, 미리 스레드 수를 고정시키는 것 또한 불가능

### 교착상태 감지 및 복구

교착상태를 감지하는 백그라운드 프로그램을 상시적으로 실행시켜 교착상태를 감지하고 해제하는 방법

교착상태 감지를 위해 상시 실행되기 때문에 시스템에 많은 부담이 되며 복구를 위해 프로세스나 스레드를 희생시켜야 하는 문제가 있다.

- **자원 강제 선점** : 운영체제가 교착상태에 빠진 스레드 중 하나를 선택하고 해당 스레드가 소유한 자원을 빼앗아 다른 스레드에게 할당한다.
- **롤백** : 운영체제가 교착상태가 발생할 것으로 예측되는 스레드들에 대해 그상태를 주기적으로 저장해두었다가, 교착상태 발생 시 가장 최근에 **저장해둔 상태로 복구**시켜 가장 최근 상태로 돌아가게 한다.
- **스레드 강제 종료** : 교착상태에 빠진 스레드 중 하나를 강제로 종료시킨다.

### 교착상태 무시 (타조 알고리즘)

교착상태가 발생할 가능성은 극히 적지만 교착상태를 처리하기 위한 비용이 많이 들어간다.

교착상태에 대한 아무런 대책없이 교착상태가 발생하면 시스템을 재시작하거나 특정 스레드를 강제 종료하는 방법

### ref)
황기태 교수님의 명품 운영체제

[https://cocoon1787.tistory.com/858](https://cocoon1787.tistory.com/858)

[https://velog.io/@dltmdrl1244/운영체제-Ch07-교착상태-Deadlock](https://velog.io/@dltmdrl1244/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch07-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-Deadlock)

