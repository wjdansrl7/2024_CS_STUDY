# 동시성 제어

DBMS 가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 Database 를 보호하는 것

일반적인 어플리케이션은 다수의 사용자의 요청을 처리하고 이러한 요청에는 DB 접근을 필요로 하는 요청도 포함합니다.
이때 한번에 다수의 DB 접근을 필요로 하는 요청이 들어올 때 트랜잭션 단위로 **DB 접근을 하게 되는데 DB 접근을 동시적으로 모두 허용해주면 데이터베이스의 일관성과 무결성이 깨지게됩니다**

동시성 제어를 통해 데이터베이스를 보호할 수 있습니다.
동시성 제어 는 병행 제어 라고도 불리며 한번에 들어온 **복수의 트랜잭션을 직렬화 하는 수행을 보장**합니다

> **일관성이란?**
>
> 동시성이 높을 수록(여러 트랜잭션이 동시에 DB 접근이 가능할수록) 데이터베이스의 일관성이 깨지게됩니다.
> 따라서 **동시성과 일관성은 반비례 관계**입니다

## 동시성 제어 목적

> 여러 사용자가 DB에 접근하더라도 데이터의 일관성을 보장하고 데이터의 무결성을 유지
> 위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것

1. 분실된 갱신(Lost Update)

- 두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우

  ![alt text](/DB/images/image.png)

  > 다수의 transaction이 동시에 실행되는 환경에서 위와 같이 서로 다른 transaction이 UPDATE 연산을 연속으로 수행하면, 먼저 실행된 UPDATE 연산이 overwriting 된다. 즉, 먼저 실행된 transaction A는 정상적으로 실행되었으나, $x$의 값은 변경되지 않는 문제가 발생한다.

2. 모순성(Inconsistency)

- 두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우

  ![alt text](/DB/images/image-2.png)

  > 상황에서는 Transaction A가 $var3$를 읽기 전에 Transaction B가 UPDATE 연산을 실행하여 $sum$이 110이 되는 잘못된 결과가 발생한다.

3. 연쇄복귀(Cascading Rollback)

- 두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우

4. 비완료 의존성(Uncommitted Dependency)

- 한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우

  ![alt text](/DB/images/image-1.png)

  > Transaction B가 $x$의 값을 변경한 다음, 변경된 $x$의 값을 Transaction A가 읽은 상황에서 Transaction B의 실행이 취소되었다. 만약, [그림 2]와 같은 상황이 발생하면, 실제로 데이터베이스에 저장된 $x$의 값과 Transaction A가 읽은 $x$의 값이 일치하지 않는 문제가 발생한다.

## 동시성 제어 기법 종류

1. locking : 트랜잭션이 데이터에 잠금(Lock) 을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제(UnLock)될 때까지 접근/수정/삭제 불가.
2. time stamp : 시스템에서 생성하는 고유 식별자인 타임 스탬프를 트랜잭션에 부여함으로써 트랜잭션 간의 접근 순서를 미리 정함.
3. MVCC(다중버전 동시성 제어 기법) : 이전 버전의 데이터와 비교해서 변경된 내용을 기록

## 로킹 기법(Locking Method)

- 트랜잭션이 사용하는 데이터 자원에 대하여 상호 배제(Mutual Exclusive) 기능을 제공하는 기법

> 상호 배제는 트랜잭션이 데이터 항목에 대하여 잠금(Lock) 을 설정한 트랜잭션이 해재(UnLock) 할 때까지 데이터를 독점적으로 사용할 수 있는 것을 의미

### 로킹 기법 종류

1. 공유 Lock(Shared Lock)

> - 공유 잠금한 트랜잭션이 데이터 항목에 대하여 읽기(Read) 만 가능. <br>
> - 다른 트랜잭션도 읽기(Read) 만을 실행 할 수 있는 형태

- 공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다.

  > T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다.

- 하나의 데이터 항목에 대해 여러 개의 공유잠금이(S-lock) 가능하다.

  > T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다.

- 다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다.
  > T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다.

2. 베타 Lock(Exclusive Lock)

> 전용 잠금한 트랜잭션은 데이터 항목에 대하여 읽기(Read) 와 기록(Write) 모두 가능
> 다른 트랜잭션은 읽기(Read) 와 기록(Write) 모두 할 수 없음

- 배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다.

      > T1에서 x에 대해 X-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다.

  하나의 데이터 항목에 대해서는 하나의 배타잠금(X-lock)만 가능하다.

- 동시에 여러 개의 배타잠금은 불가능하다.

  > T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다.

- 다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다.

  > T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다.

> **교착 상태** <br>
> 두 트랜잭션이 각각 Lock 을 설정하고 서로의 Lock 에 접근하여 값을 얻어오려 할 때 이미 각 트랜잭션에 의해 Lock 이 설정되어 있기 때문에 트랜잭션이 영원히 처리가 되지않게 되는 상태를 말합니다. 두 트랜잭션이 공유락을 사용한다면 교착 상태는 발생하지 않습니다. 하지만 그 외 경우에는 주의를 해서 설계 해야합니다

## Locking을 활용한 동시성 제어

1. 낙관적 락

- 자원에 lock을 직접 걸어서 선점하지 않고, **동시성 문제가 실제로 발생하면** 그때가서 처리하는 방식
- 충돌이 발생하면 **재시도 or 병합**을 통해 해결
- 실제로 lock이 아니라 version을 이용해서 정합성을 맞추는 방법이다. 데이터를 읽을 때 **lock을 사용하지 않고 업데이트 시 내가 읽은 version이 맞는 지 충돌 여부를 확인**하여 처리한다.

> 충돌할 확률이 적을 때 사용된다.

2. 비관적 락

- 트랜젝션이 시작할 때 **s-lock이나 x-lock을 실제로 걸고 시작**한다.
- 실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
- 데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.

> 충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.

![transaction_slock&xlock](/DB/images/transaction_slock&xlock.png)

3. 분산락 (distributed lock)

- **여러 컴퓨터 또는 프로세스 간에 공유된 자원**에 대한 동시 액세스를 제어하기 위해 사용된다.
- 분산 시스템에서 동시성 문제를 해결하기 위해 사용되며, 분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
- 주로 데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
- 대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.

### Redis

Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다.

- 오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
- 락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
- Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다.

분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다.

## 타임 스탬프 (Time Stamp)

- 트랜잭션의 순서대로 **시간 스탬프를 지정**하여 동시성 제어의 기준으로 사용되는 개념

- 타임 스탬프에는 System 시계 사용법, 논리적 계수 사용법 이 존재.

> System 시계 사용법 : 트랜잭션이 트랜잭션이 시스템에 들어올 때의 system clock 적용 <br>
> 논리적 계수 사용법 : 트랜잭션의 시간 스탬프는 그 트랜잭션이 시스템에 들어올 때의 시스템 계수기의 값과 같은 개념

## MVCC(다중버전 동시성 제어 기법)

MVCC(Multi Version Concurreny Control)

> lock은 해당 데이터를 선점한 사용자가 데이터의 lock을 해제하기 전까지는 다른 사용자가 해당 데이터를 컨트롤하는데 제약이 있다. MVCC는 이런 lock의 단점을 보완하기 위한 것이다.

MVCC는 데이터의 업데이트를 할 때, 기존의 내용을 덮어쓰지 않고, 그 데이터의 새로운 버전을 만든다.(snapshot)
쉽게 말해서, A가 D라는 데이터의 D-0버전을 write 할 때, MVCC는 D데이터의 D-1버전을 만들고, 만약 write 도중에 B가 D데이터에 접근하면 D-0버전을 raed 할 수 있도록 해주는 것이다.
때문에 MVCC는 이론상 lock의 개념이 필요없다. (하지만 일부 DBMS들은 MVCC와 lock을 함께 사용한다고 한다.)

### MVCC의 특징

- lock 기법만 적용된 DBMS보다 훨씬 빠르게 동작한다.
- 불필요한 데이터(위에서 말한 데이터 버전과 같은)이 많이 쌓여서 주기적으로 이를 정리해줄 별도의 시스템이 필요하다
- 데이터 버전이 충돌할 가능성이 있음 (따라서 실제로는 MVCC와 lock을 같이 사용한다)

실제 MVCC는 트랜잭션의 격리 수준(Isolation Level)에 따라 다르다고 합니다. 만약 커밋되지 않은 내용도 조회하도록 해주는 READ_UNCOMMITTED라면 버퍼 풀의 데이터를 읽어서 반환하며, 이는 커밋 여부와 무관하게 변경된 데이터를 읽어 반환한다.
만약 READ_COMMITED 이나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)이라면 변경되기 이전의 Undo 로그 영역의 데이터를 반환하게 된다. 이것이 가능한 이유는 하나의 데이터에 대해 여러 버전을 관리하는 MVCC 덕분이다.
여기서 Undo Log 영역의 데이터는 커밋 혹은 롤백을 호출하여 InnoDB 버퍼풀도 이전의 데이터로 복구되고, 더 이상 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.

#### Ref.

- https://this1.tistory.com/entry/MVCC%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC-%EC%A0%95%EB%A6%AC
- https://mangkyu.tistory.com/53
