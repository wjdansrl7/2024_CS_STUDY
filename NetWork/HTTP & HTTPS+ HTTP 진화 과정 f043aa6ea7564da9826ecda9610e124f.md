# HTTP & HTTPS+ HTTP 진화 과정

## HTTP(Hyper Text Transfer Protocol)

### 정의

- 서버와 클라이언트가 서로 hyper text 데이터를 주고 받기 위한 프로토콜(통신 규약)
    - hyper text란 : 하이퍼링크를 통해 사용자가 한 문서에서 다른 문서로 이동할 수 있도록하는 글.
        
        ex) html(hyper text markup language) 문서간 이동이가능한 텍스트의 구조를 나타낸 언어.
        
- 문서 뿐만 아니라 거의 모든 형태의 데이터가 전송 가능
- 한 문서에서 다른 문서로 이동할 수 있도록 글을 주고 받는 약속
- 기본포트 80

### 구조

1. 클라이언트와  서버로 나눠진 구조로 되었다. request 와 response로 이뤄지며 클라이언트가 요청하면 서버가 응답한다. 
2. 사용자는 링크를 눌러 서버에 홈페이지 정보를 요청하며 통신을 시작한다.
3. 서버는 사용자의 요청에 따라 홈페이지 정보를 응답하고 통신을 종료한다.
4. 정보를 받은 사용자의 브라우저는 정보를 화면에 띄운다.

애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. 

### 인터넷 프로토콜 스택의 4계층

- 애플리케이션 계층 - HTTP,FTP
- 전송 계층 - TCP,UDP
- 인터넷 계층 - IP
- 네트워크 인터페이스 계층

### HTTP특징

1. 무상태(Stateless)
    - 무상태(stateless)는 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미.
    - stateful의 경우에는 상태를 유지해야 하므로 항상 같은 서버가 유지되어야 한다. 하지만 stateless는 상태를 보관하지 않으므로 클라이언트의 요청에 어느 서버가 응답해도 상관 없다. 따라서 클라이언트의 요청이 대폭 증가해도 서버를 증설해 해결할 수 있다.
    - 하지만 모든 것을 stateless로 설계할 수 없다. 단순히 로그인만 보더라도 사용자가 로그인한 상태를 서버에 유지시켜 주어야 한다. 이 경우에는 브라우저 쿠키나 서버 세션 등을 사용해 상태를 유지한다.
2. 비연결성(Connextionless)
    - 비연결성은 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지 하지 않는 것이다. 이를 통해 서버의 자원을 효율적으로 관리하고, 수 많은 클라이언트의 요청에도 대응할 수 있게 한다.
    - 현재는 HTTP 지속 연결(Persisten Connections)로 문제를 해결했다. 지속 연결은 요청에 따라 연결이 된 이후 일정 시간 연결을 유지하거나 여러 개의 요청(HTML, 자바스크립트, 이미지 등)에 대한 응답이 다 올 때 까지 기다린 후 연결을 종료하는 것이다
    

### HTTP메서드

- GET :리소스 조회
    - 보통 리소스를 조회할 때 사용하며, 서버에 전달하고 싶은 데이터는 query를 통해서 전달한다. 메시지 바디를 사용해서 데이터를 전달할 수는 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다.
- POST : 요청 데이터 처리, 주로 데이터 등록에 사용
    - 데이터 요청을 처리하고, 메시지 바디를 통해 서버로 데이터를 전달한다. 주로 신규 리소스를 등록하거나 프로세스 처리에 사용된다.
- PUT : 리소스를 대체, 해당 리소스가 없으면 생성
    - 리소스가 있으면 대체하고 리소스가 없으면 생성한다. 쉽게 말해 데이터를 덮어쓴다.
- PATCH :  리소스를 일부분만 변경
    - PUT과 마찬가지로 리소스를 수정할 때 사용하지만, PATCH는 리소스를 일부분만 변경할 수 있다.
- DELETE : 리소스 삭제
    - 리소스를 제거할때 사용한다.

### 기타 메소드 4가지

- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션을 설명 (주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### HTTP메서드 특성

1. 안정성
    - 계속해서 메소드를 호출해도 리소스를 변경하지 않는다는 뜻이다. 주요 메소드중에는 GET 메소드가 안전하다고 볼 수 있다.
2. 멱등성
    - 메소드를 계속 호출해도 결과가 똑같다는 뜻이다. GET, PUT, DELETE는 멱등하다고 볼 수 있지만 POST나 PATCH는 멱등하다고 볼 수 없다.
        - GET : 몇번을 조회하더라도 같은 조회가 된다.
        - PUT : 결과를 대체한다. 따라서 같은 요청을 여러번해도 최종 결과는 같다.
        - DELETE : 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
        - POST : 멱등이 아니다. 두 번 호출하면 에러가 발생할수 있다. POST로 주문을 두번 호출하면 결제가 중복될 수 있다.
        - PATCH : 멱등일 수도 있고 아닐수도 있다.  PATCH 메소드는 PUT 메소드처럼 리소스를 대체하는 행위가 아니기 때문에 요청을 어떤 방식으로 사용하는지에 대한 제한이 딱히 없기 때문이다. 호출할 때마다 나이를 증가시키는 PATCH메소드가 있으면 호출될 때마다 결과가 달라지므로 멱등이아니다.
3. 캐시가능
    - 캐싱을 해서 데이터를 효율적으로 가져올 수 있다는 뜻이다. 응답 결과를 캐시해 사용할 수 있는 속성. GET, HEAD, POST, PATCH가 캐시가 가능하지만 실제로는 GET과 HEAD만 주로 캐싱이 쓰인다고 한다.
    

### HTTP 상태코드

http 상태 코드는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능.

1xx (Informational) : 요청이 수신되어 처리중

2xx (Successful) : 요청 정상 처리

3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요

4xx (Client Error) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음

5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함

 

### HTTP는 암호화 되지 않은 평문 데이터를 전송하는 프로토콜이므로 HTTP로 중요 정보를 주고받으면 제3자가 정보를 조회할 수 있다. 이를 해결하기 위해 HTTPS가 등장했다.

## **HTTPS (Hyper Text Transfer Protocol Secure)**

### 정의

- http에 데이터 암호화가 추가된 프로토콜.
- 네트워크 상에서 제3자가 정보를 볼 수 없도록 암호화를 지원하고 있다.
- 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용.
- 일반적으로 'SSL' 또는 'TLS' 프로토콜을 이용해 데이터를 암호화한다.
- 443포트 사용

### **https동작과정**

공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 하이브리드 사용

데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키 전달. 

1. 클라이언트가(브라우저) 서버로 최초 연결을 시도
2. 서버는 인증서를 브라우저에게 넘겨줌
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 암호화하여 서버로 전송함.

1. **클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색**
    
    1.1. **Client Hello**
    
    - 클라이언트가 서버에게 전송할 데이터
        - 클라이언트 측에서 생성한 **랜덤 데이터**
        - 클-서 암호화 방식 통일을 위해 **클라이언트가 사용할 수 있는 암호화 방식**
        - 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 **세션 아이디**
    
    1.2. **Server Hello**
    
    - Client Hello에 대한 응답으로 전송할 데이터
        - 서버 측에서 생성한 **랜덤 데이터**
        - **서버가 선택한 클라이언트의 암호화 방식**
        - **SSL 인증서**
    
    1.3. **Client 인증 확인**
    
    - 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고, 목록에 있다면 CA 공개키로 인증서 복호화
    - 클-서 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭키 암호화에 사용할 키)
    - pre master secret 값을 공개키 방식으로 서버 전달(공개키는 서버로부터 받은 인증서에 포함)
    - 일련의 과정을 거쳐 session key 생성
    
    1.4. **Server 인증 확인**
    
    - 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
    - 일련의 과정을 거쳐 session key 생성
    
    1.5. **Handshaking 종료**
    
2. **데이터 전송**
    - 서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신
3. **연결 종료 및 session key 폐기**

## HTTP + HTTPS 진화과정

- HTTP/0.9
    - 문서화된 최초의 HTTP버전
- HTTP/1.0
    - 기존 HTTP의 기능을 확장한 버전
    - 버전정보가 명시되었고 각 요청 응답 사이에서 전송됨.
    - 요청 메서드가  GET,HEAD,POST 세가지로 확장됨
    - 상태코드가 추가되어 클라이언트 측에서 요청결과에 따라 동작할 수 있게 됨
    - 요청과 응답에 대한 부가적인 메타데이터를 담는 헤더 필드가 추가됨
    - HTTP 헤더(Content-Type) 의 도움으로 HTML이외의 파일도 전송할 수 있게 됨

### HTTP/1.1

- 표준화된 HTTP
- 기존 1.0에서는 요청에 따른 응답이 수신되면 TCP연결을 바로 종료. ⇒ 1.1은 연결상태 유지. 한번 수립한 연결을 재사용
    - Keep-Alive : 연결을 유지하는 시간이 길어질 수록 서버에 부하가 생기기 때문에 연결을 유지하는 시간을 제한
- 파이프라이닝
    - 클라이언트가 여러 요청을 연달아 보내야 할 때, 각 응답을 기다리는 것이 아니라 발생한 요청은 일단 전송하고 보는 방식. 일단 클라이언트 측에서 여러 요청을 순차적으로 보내면, 서버는 받은 순서에 따라 응답을 제공하는 방식으로 지연을 개선. 이 때 각 요청 별 응답을 구분하기 위해 순서를 엄격히 지켜야한다.
- HOLB(Head-of-Line Blocking) 문제
    - 서버가 항상 요청받은 순서대로 응답해야한다.
    - 하나의 연결 내에서 응답 다중화(multiplexing)을 할 수 없었기 때문에 요청이 순차적으로 처리되야했다. 서버가 응답 작성 중간에 문제가 생기면 후속 요청들이 전송되지 못하고 지연되는 문제 생김.
- 해더 중복 문제
    - 헤더에 많은 메타데이터가 담기고, 이를 매 요청마다 헤더를 중복해서 전송해야 했다.
- HTTPS/RESTful API의 탄생

### HTTP/2

- TCP기반의 SPDY프로토콜 → HTTPS강제
- 이진 프로토콜 (바이너리 프레이밍)
    - 1.1의 텍스트 기반 프로토콜 에서 데이터 크기 문제로 인해 이진 프로토콜로 변경
- 스트림, 메시지, 프레임으로 구분
    - 스트림 : 요청과 응답이 양방향으로 오가는 논리적 연결 단위, TCP연결에서 여러 개의 스트림이 동시에 존재할 수 있음
    - 메시지 : 하나의 요청과 응답을 구성하는 단위
    - 프레임 : 메시지를 구성하는 최소 단위, 잘게 쪼개어 전송되기 때문에 수신 측에서 다시 조립하여 사용
    
- 멀티플렉싱(응답 다중화) → HOLB 문제 해결
    - TCP연결을 스트림, 메시지, 프레임 단위로 세분화했기 때문에 하나의 TCP연결에서 여러 요청을 동시에 처리할 수있다.
- HPACK (헤더필드 압축) → 헤더 중복 문제 해결
- 서버 푸시
    - 서버가 클라이언트가 요청하지 않은 리소스를 미리 클라이언트에게 보낼 수 있다.
- 스트림 별 우선 순위 설정
- TCP 자체의 HOLB문제
    - 여전히 TCP위에서 동작하기 때문에 TCP로 인해 발생하는 문제를 해결 할 수 없다.
    - TCP는 신뢰성을 지향하기 때문에 데이터 손실이 발생하면 재전송을 수행. 또한 패킷을 정확한 순서로 처리해야 하기 때문에 재전송을 수행하고 대기하는 과정에서 병목 현상 발생.

### HTTP/3

- UDP기반의 QUIC프로토콜
    - TCP의 신뢰성을 보장하기 위해 제공되는 기능들을 UDP기반으로 직접 구현하여 성능을 개선한 QUIC사용
- 연결다중화를 지원하면서 독립 스트림
    - TCP HOLB문제 해결
    - 연결 내 스트림이 독립적으로 동작하기 때문에 데이터손실이 발생해도 다른 스트림에 영향을 주지 않는다.
- QPACK → 헤더 압축 문제 개선
- 캐싱을 이용한 0-RTT
    - TCP의 경우 최초 연결 수립 시 3-way 핸드셰이크 과정이 필요하지만 HTTP/3은 최초 연결 설정에서 연결에 필요한 정보들과 데이터를 함께 전송하여 1-RTT로 시간을 절약한다. 또한 한번 성공한 연결은 캐싱해 놓았다가 다음 연결 때에는 캐싱된 정보를 바탕으로 바로 연결을 수립하여 0-RTT가능.
- Connection ID 기반
    - 기존의 IP기반에서 연결별 고유 UUID를 이용해 각 연결을 식별.
    - 기존의 IP기반은 IP주소가 변경되는 경우 연결 재수립과정을 거쳐야 하지만 연결 ID는 연결을 그대로 유지 가능.
- 서버 푸시
- 스트림 별 우선 순위
- TLS → HTTPS 강제

[https://ssow93.tistory.com/17](https://ssow93.tistory.com/17)

[https://yozm.wishket.com/magazine/detail/1686/](https://yozm.wishket.com/magazine/detail/1686/)

참고자료

[https://inpa.tistory.com/entry/HTTP-🌐-백엔드-로드맵-HTTP는-무엇일까요](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94)

[https://overcome-the-limits.tistory.com/554](https://overcome-the-limits.tistory.com/554)

[https://mangkyu.tistory.com/98](https://mangkyu.tistory.com/98)

[https://velog.io/@averycode/네트워크-HTTP와-HTTPS-동작-과정](https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP%EC%99%80-HTTPS-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95)