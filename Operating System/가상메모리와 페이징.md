# 가상 메모리와 페이징

> 메모리 관리 기법 중 하나로 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

- 사용자 프로그램이 **물리 메모리 제약에서 벗어남**
- 각 프로그램이 더 **작은 메모리를 차지**하기 때문에 더 많은 프로그램 동시수행 가능(한것처럼 보임)
- 프로그램을 메모리에 올리고 swap하는 데 필요한 **IO 횟수가 줄어든다.**


### CPU 동작

- CPU는 연산할 때 메모리 값을 참조 

    - 레지스터를 참조 : 메모리를 자료를 보관하는 매우 빠른 기억 장소. 
    하지만 레지스터는 용량이 매우 작음. 
    - 메인 메모리 : 가까운 곳의 레지스터보다는 조금 느리지만 좀 더 큰 메인메모리를 사용. 즉 피지컬 메모리를 통해 참조한다. 
    - 보조 기억 장치 값을 사용하려면 os의 도움이 필요하다.

> cpu는 메인 메모리의 값까지만 참조할 수 있다. 즉 cpu가 일을 하기 위해서는 프로그램의 정보가 메모리에 올라와야 한다.


### 프로그램 실행 과정

> 프로그램이 실행 = cpu가 일을 하는 것. cpu가 일을 하기 위해서는 프로그램 정보가 메모리에 올라와야 함. 

- 프로그램은 디스크에 이진 소스파일로 존재. 
- 컴파일로 링커 작업을 통해 실행파일이 실행된다. -> 실행되기 위해서는 프로그램을 메모리로 가져와 프로세스의 형태로 배치해야 한다. 해당 프로그램의 정보가 cpu가 참조할 수 있는 형태로 물리메모리에 올라가야 한다는 것. 
- 실행파일을 실행하면 fork요청으로 새 프로세스를 생성하고 프로세스를 exec요청으로 로더를 호출. 로더는 새로 생성된 프로세스의 주소공간을 사용하여 지정된 실행파일을 메모리에 올리는 데 사용된다. 

> 프로그램을 실행하면 디스크에 존재하는 실행파일이 메모리에 올라오고 cpu가 해당 정보를 참조할 수 있게 된다.

## 논리 주소

> cpu는 실행파일을 실행하면, 프로세스마다 논리적인 주소 공간을 생성한다. 이 주소를 바라보는 데 이를 논리 주소라고 한다. 

## 주소 바인딩

> cpu가 일을 하기 위해서는 논리 주소가 메인 메모리상에 올라와 있어야 한다. 논리 주소가 물리적 메모리의 특정 위치로 맵핑 되는데 이 작업을 주소 바인딩이라고 한다.

> 바인딩 시점에 따라서 논리주소와 물리 주소의 값이 같을 수도 있지만 아닐 수도 있다!

주소 바인딩은 물리적 메모리 주소가 결정되는 시기에 따라 종류가 나누어진다.

- 컴파일 타임 바인딩 
- 로드타임 바인딩
- 실행시간 바인딩

> 가상 메모리를 사용하기 위해서는 실행시간 바인딩이 지원되어야 한다.(이 기법을 사용하면 논리주소와 물리 주소가 달라지게 된다.)


### 실행시간 바인딩 
- 실행시간 바인딩을 하기 위해서는 하드웨어 지원이 필요하다 

> cpu가 값을 참조할 때마다 주소 매핑테이블을 이용해 바인딩을 진행한다. 그러기 위해서는 기준 레지스터(물리주소 시작점), 한계 레지스터(논리주소의 끝점)를 포함해 mmu(메모리 관리 장치)라는 하드웨어의 지원이 필요하다. 


- 기준 레지스터는 현재 프로세스의 물리적 메모리의 시작 주소가 저장되어 있어, **논리주소 + 기준레리스터**의 값으로 물리적 주소를 찾는다.

-  **프로세스는 자기만의 고유한 주소공간**을 가지기 때문에 동일한 논리주소 값이라도 프로세스 마다 서로 다른 내용을 담고 있다.


### 시분할 방식

- cpu는 이러한 과정(메모리 값 참조, 논리 주소, 주소바인딩)을 통해 프로세스를 실행. 

- cpu가 하나라면 일할 수 있는 자원은 한개. 우리는 여러 프로그램을 동시에 실행하고 싶다. => **cpu가 짧은 시간 단위로 프로세스**를 바꾸어 가며 실행한다.


### 스왑영역

> cpu가 프로세스를 실행하려면 메로리에 올라와 있어야 하는 데 여러개의 프로그램이 메모리에 올라오면 메모리가 부족하다. => 메모리 공간의 확장영역으로 swap 공간을 사용한다.

- 스왑공간은 외부저장장치에 존재한다. 

- 물리메모리의 확장개념이기에, 물리 메모리에 공간이 부족으로 인해 실행중인 프로세스의 주소공간을 일시적으로 메모리에서 디스크로 내려놓기 위한 영역. 

- 스왑영역은 디스크에 존재하지만 파일시스템과는 별도로 존재. 

> 파일시스템은 비휘발성. 스왑영역을 메모리 공간의 확장으로 사용하기 때문에 프로세스가 수행중인 동안에만 일시적으로 저장된다.

- 메모리에서 스왑영역으로 이동을 스왑 in 스왑 out이라고 한다. 

- 스왑영역도 외부영역에 존재해 os에 의해 io작업이 일어남. 공간보다는 시간 효율성을 고려하기에 일반적인 경우보다는 빠르다. 


## 가상메모리가 왜 필요한가?

> 실행되고 있는 프로세스의 내용은 모두 물리 메모리에 올라와 있어야 한다. 여러 개의 프로그램을 실행하는 환경에서 물리 메모리를 나눠서 사용하게 된다. 여러개를 사용할 수도록 각 프로그램에게 할당할 수 있는 물리 메모리가 줄어든다. 다른 프로세스를 올려야 해서 공간이 부족해 진다면, 기존 프로세스를 스왑영역으로 보내고 필요한 프로세스가 물리 메모리에 올라와야 합니다. 이렇게 되면 빈번하게 스왑영역과 io가 발생. 물리 메모리의 크기를 벗어나는 프로세스라면 실행조차 불가능 -> 가상 메모리의 개념이 필요하게 됨.

- 물리 메모리의 크기를 벗어나는 프로세스라면 실행조차 불가능 
- 좋은 프로세스일수록 사용하지 않은 코드가 많이 존재. 이것들을 모두 메모리에 올려야 하는가? 비효율!
- 다른 프로세스를 올려야 해 메모리가 부족해 진다면 swap영역과 io가 빈번하게 발생한다. 비효율!


# 가상 메모리란?

-  가상 메모리는 실제의 물리 메모리와 논리 메모리를 분리해서 사용. 

- 가상 메모리를 사용하면 프로세서 전체의 전체의 내용을 메모리에 올릴 필요 없이, 필요한 부분만 메모리에 올려 실행이 가능하다. 

> 어떻게 필요한 정보만 올릴 수 있는가? 필요한 부분만 메모리에 올리는 **요구 페이징 기법**을 사용.

## 요구 페이징 기법

- 주소 공간이 하나의 단위가 아니라 여러개의 페이지로 나누고, 당장 필요한 부분만 물리 메모리에 가져와 사용한다. 

- 유무효 비트
    > 특정 페이지가 물리 메모리에 올라와 있는 지 구분하기 위해 유무효 비트를 사용한다.

    - valid 비트 : 해당 페이지가 메모리에 올라와 있음.
    - Invalid 비트 : 해당 페이지가 물리메모리에 없음.

#### 요구 페이징 기법 동작

1. 물리 메모리에 대응되는 페이지 테이블에 valid, invalid 비트로 물리적 메모리에 페이지의 바인딩 정보를 확인.

> 이때, 앞서 말한 mmu의 도움을 받아 실행타임 바인딩 기법이 적용된다. 

2. invalid 비트인 페이지를 참조한다면 cpu 제어권이 os에게 넘어간다.
3. 스왑영역에서 해당 페이지를 참조해서 물리메모리의 빈 공간에 올리게 된다. 

> 이렇게 필요한 페이지만 물리적 메모리에 올려서 사용하는 기법을 요구 페이징 기법이라고 한다.

> 상대적으로 큰 저장공간인 스왑영역을 활요아여 프로세스마다 가상의 주소공간을 확보하고, 필요한 정보만 물리메모리에 올려 사용함으로 더 효과적으로 물리 메모리를 사용할 수 있게 된다. 

> 따라서 프로그램이 물리적 메모리의 크기를 고려한 필요없이, 자기 자신만의 메모리를 사용하는 것처럼 가정하에 프로그램을 수행한다.


# 가상메모리와 요약

- 사용자 프로그램이 **물리 메모리 제약에서 벗어남**

> 사용자 프로그램이 물리 메모리보다 커져도 된다. 프로그래머는 물리 메모리 크기를 신경쓰지 않아도 되기 때문에 실제 해결하고자 하는 문제에 집중 가능 

- 각 프로그램이 더 **작은 메모리를 차지**하기 때문에 더 많은 프로그램 동시수행 가능(한것처럼 보임)

> 프로세스 당 메모리 사용량이 감소하고, 더 많은 프로세스를 수용할 수 있다. 응답시간은 늘리지 않으면서 cpu 이용률과 처리률이 높아짐

- 프로그램을 메모리에 올리고 swap하는 데 필요한 **IO 횟수가 줄어든다.**

> io가 적게 일어나므로 더 빨리 실행 가능



# 페이지 교체 알고리즘

> 요구 페이징 기법은 페이지 부재시에는 새로운 페이지를 할당해야 한다. 하지만 메인 메모리가 이미 포화상태라면? 특정 페이지를 교체해야한다! -> 어떤 페이지를 내보내야하는 가? 

- 가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 올려도 메모리는 결국 가득 차게 된다.
- 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음

->  메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 한다. 이때 어떤 페이지를 out 시켜야할 지 정해야 함. (이때 out 되는 페이지를 victim page라고 부름)

> 이후에도 방문하지 않을 페이지를 내보내는 것이 좋다!


1. #### FIFO 알고리즘

   > First-in First-out, 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘

   - victim page : out 되는 페이지는, 가장 먼저 메모리에 올라온 페이지

   - 가장 간단한 방법으로, 특히 초기화 코드에서 적절한 방법임

   > 초기화 코드 : 처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로, 메인 메모리에서 빼도 괜찮음

   하지만 처음 프로세스 실행시에는 무조건 필요한 코드이므로, FIFO 알고리즘을 사용하면 초기화를 시켜준 후 가장 먼저 내보내는 것이 가능함

   <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FVQCGK%2FbtquJuqRkyS%2FLb3NgwHkBve08YhZpLkq31%2Fimg.png">

<br>
<br>

2. #### OPT 알고리즘

   > Optimal Page Replacement 알고리즘, 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄

   - FIFO에 비해 페이지 결함의 횟수를 많이 감소시킬 수 있음

   - 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려운 알고리즘임

   <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FSvRs7%2FbtquHbeJLQX%2FWXmK7xdGUbIxl43t0JG6Qk%2Fimg.png">

<br>

3. #### LRU 알고리즘

   > Least-Recently-Used, 최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘

   - 최근에 사용하지 않았으면, 나중에도 사용되지 않을 것이라는 아이디어에서 나옴
   - OPT의 경우 미래 예측이지만, LRU의 경우는 과거를 보고 판단하므로 실질적으로 사용이 가능한 알고리즘

   > 실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높다

   > OPT보다는 페이지 결함이 더 일어날 수 있지만, **실제로 사용할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법 중 하나임**

   <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FnCgc3%2FbtquGW9VUrm%2FxTKnVKPOVQuSXmAuRehSw1%2Fimg.png">



### 교체 방식

> 다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라온다. 즉 다양한 프로세스의 페이지가 메모리에 존재한다. 따라서 페이지 교체 시, 다양한 페이지 교체 알고리즘을 활용해 victim page를 선정하는데, 선정 기준을 Global로 하느냐, Local로 하느냐에 대한 차이

- Global 교체 :메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식
- Local 교체 : 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

>  실제로는 전체를 기준으로 페이지를 교체하는 것이 더 효율적이라고 함. 자기 프로세스 페이지에서만 교체를 하면, 교체를 해야할 때 각각 모두 교체를 진행해야 하므로 비효율적
