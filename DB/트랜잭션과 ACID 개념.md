# 트랜잭션
- 논리적인 작업 단위 (a single logical unit of work)
- 논리적인 이유로 여러 SQL문들을 단일 작업으로 묶어서 나누어질 수 없도록 만든 것
- 트랜잭션 내 SQL문들은 모두 성공하는 경우 commit되고, 하나라도 실패하는 경우에는 전체가 rollback된다.
- 트랜잭션 내 SQL문 중에 일부만 성공해서 DB에 반영되는 일은 일어나지 않는다. 
 

## 트랜잭션 ACID란?

- 트랜잭션이 어떤 속성을 지녀야 하는지 나타내는 핵심
- 트랜잭션은 ACID라 규칙을 모두 보장해 데이터베이스 트랜잭션이 안전하게 수행되어야 한다.
- 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)의 앞글자를 딴 규칙
 

### 원자성(Atomicity)
트랜젝션은 분해가 불가능한 최소의 단위인 하나의 원자처럼 동작해야 한다. 즉 트랜젝션 내의 모든 연산들은 반드시 한꺼번에 완전하게 전체가 정상적으로 수행이 완료되거나 아니면 어떠한 연산도 수행되지 않아야 한다 -> all or noting

> 트랜잭션은 논리적으로 쪼개질 수 없는 작업 단위이기 때문에 내부의 SQL문들이 모두 성공하고나, 중간에 어떤 하나의 SQL문이라도 실패하면, 지금까지 작업을 모두 취소해 이전 상태로 롤백해야 한다.  

> 성공 시 커밋했을 때 DB에 영구적으로 저장하는 것과 실패 시 롤백했을 때 이전 상태로 되돌리는 것은 DBMS가 담당하는 부분이다. 
> 개발자는 언제 커밋하고 언제 롤백할 지에 대한 기준을 세우고 코드를 작성해야 한다.



### 일관성(Consistency)
트랜잭션 이전과 이후에 데이터베이스는 항상 consistent한 상태여야 한다.
만약에, constraints, trigger 등을 통해서 DB에 정의된 규칙을 트랜잭션이 위반했다면 롤백해야 한다.

> 예시 1) 계좌에 잔액을 업데이트하는 트랜잭션 결과로 잔액이 마이너스로 가버렸다면 그냥 롤백해야 한다.
> 예시 2) 게시판에 글을 쓰는데 글자 제한이 255자라고 한다면, 트랜잭션이 일어나면 해당 조건을 만족해야 한다. 만약 이를 위반하는 트랜잭션이 있다면 거부해야한다.


> 트랜잭션이 DB에 정의된 규칙을 위반했는지는 DBMS가 커밋 전에 확인하고 알려준다.
> 그렇다고 DBMS를 맹신하기보다는, 애플리케이션 관점에서 트랜잭션이 consistent하게 동작하는지는 개발자도 챙겨야 한다. 

 
### 고립성(Isolation)

여러 트랜잭션이 동시에 실행될 때에도, 혼자 실행되는 것처럼 동작하게 만들어야 한다. 즉, 동시에 실행되는 여러 트랜잭션은 서로 영향을 주지 않고 독립적으로 실행되는 것처럼 보여야 한다. 따라서 다수의 트랜잭션이 동시에 수행중인 상황에서 하나의 트랜잭션이 완료될 때까지는, 현재 실행 중인 트랜잭션의 중간 수행결과를 다른 트랜잭션에서 보거나 참조 할 수 없다.


> DBMS는 여러 종류의 isolation level을 제공하고, 개발자는 이중에서 어떤 레벨로 트랜잭션을 동작시킬지 설정할 수 있다. 
> concurrency control의 목표는 isolation이다. 
 


### 영속성, 지속성 (Durability)
일련의 데이터 조작(트렌젝션 조작)을 완료 하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타낸다. 즉 커밋된 트랜잭션의 결과는 데이터베이스에 영구적으로 저장되어야 한다. ('영구적 저장' == '비휘발성 메모리(HDD, SSD 등)에 저장')
따라서 DB System에 전원이 꺼진다던가 뿌서진다던가 등등 문제가 생겨도 커밋된 결과는 계속 데이터베이스에 남아있어야 한다. 

> MySQL을 포함해 많은 데이터베이스의 구현에서는 트랜젝션 조작을 하드 디스크에 로그로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전까지 복원하는 것으로 지속성을 실현하고 있다.
> 개발자가 할 수 있는 건 별로 없고, durability는 DBMS가 보장하니깐 믿고 간다. 
