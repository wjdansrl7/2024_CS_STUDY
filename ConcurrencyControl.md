# 동시성 제어

DBMS 가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 Database 를 보호하는 것

일반적인 어플리케이션은 다수의 사용자의 요청을 처리하고 이러한 요청에는 DB 접근을 필요로 하는 요청도 포함합니다.
이때 한번에 다수의 DB 접근을 필요로 하는 요청이 들어올 때 트랜잭션 단위로 DB 접근을 하게 되는데 DB 접근을 동시적으로 모두 허용해주면 데이터베이스의 일관성과 무결성이 깨지게됩니다 

동시성 제어를 통해 데이터베이스를 보호할 수 있습니다.
동시성 제어 는 병행 제어 라고도 불리며 한번에 들어온 복수의 트랜잭션을 직렬화 하는 수행을 보장합니다 


> #### 일관성이란?
> 동시성이 높을 수록(여러 트랜잭션이 동시에 DB 접근이 가능할수록) 데이터베이스의 일관성이 깨지게됩니다.
> 따라서 동시성과 일관성은 반비례 관계입니다


## 동시성 제어 목적

> 여러 사용자가 DB에 접근하더라도 데이터의 일관성을 보장하고 데이터의 무결성을 유지
> 위를 만족하며 데이터베이스 시스템의 성능과 효율성을 유지하는 것

1. 분실된 갱신(Lost Update)

- 두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하게 되면서 하나의 작업이 진행되지 않는 경우

2. 모순성(Inconsistency)

- 두개의 트랜잭션이 같은 데이터를 동시에 갱신하게되어 사용자가 원하는 결과와 일치하지 않은 상태가 되는 경우

3. 연쇄복귀(Cascading Rollback)

- 두개의 트랜잭션이 같은 데이터를 갱신하는 작업을 진행하는 과정에서 하나의 트랜잭션이 실패하면 원자성에 의해 두 트랜잭션 모두 복귀하는 경우

4. 비완료 의존성(Uncommitted Dependency)

- 한개의 트랜잭션이 실패하였을때, 이 트랜재션이 회복하기전에 다른 트랜잭션이 실패한 수행 결과를 참조하는 경우


## 동시성 제어 기법 종류
1. locking : 트랜잭션이 데이터에 잠금(Lock) 을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제(UnLock)될 때까지 접근/수정/삭제 불가.
2. time stamp : 시스템에서 생성하는 고유 식별자인 타임 스탬프를 트랜잭션에 부여함으로써 트랜잭션 간의 접근 순서를 미리 정함.
3. 적합성 검증 : 먼저 트랜잭션을 수행하고 종료할 때 적합성을 검증하여 데이터베이스에 최종 반영.


## 로킹 기법(Locking Method)

- 트랜잭션이 사용하는 데이터 자원에 대하여 상호 배제(Mutual Exclusive) 기능을 제공하는 기법

> 상호 배제는 트랜잭션이 데이터 항목에 대하여 잠금(Lock) 을 설정한 트랜잭션이 해재(UnLock) 할 때까지 데이터를 독점적으로 사용할 수 있는 것을 의미

### 로킹 기법 종류

1. 공유 Lock(Shared Lock)	

> 공유 잠금한 트랜잭션이 데이터 항목에 대하여 읽기(Read) 만 가능
> 다른 트랜잭션도 읽기(Read) 만을 실행 할 수 있는 형태

- 공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다.

    > T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다.

- 하나의 데이터 항목에 대해 여러 개의 공유잠금이(S-lock) 가능하다.

    > T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다.

- 다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다.
    
    > T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다.

2. 베타 Lock(Exclusive Lock)	

> 전용 잠금한 트랜잭션은 데이터 항목에 대하여 읽기(Read) 와 기록(Write) 모두 가능
> 다른 트랜잭션은 읽기(Read) 와 기록(Write) 모두 할 수 없음

- 배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다.

    > T1에서 x에 대해 X-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다.
하나의 데이터 항목에 대해서는 하나의 배타잠금(X-lock)만 가능하다.

- 동시에 여러 개의 배타잠금은 불가능하다.

    > T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다.

- 다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다.

    > T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다.

> 교착 상태란 두 트랜잭션이 각각 Lock 을 설정하고 서로의 Lock 에 접근하여 값을 얻어오려 할 때 이미 각 트랜잭션에 의해 Lock 이 설정되어 있기 때문에 트랜잭션이 영원히 처리가 되지않게 되는 상태를 말합니다. 두 트랜잭션이 공유락을 사용한다면 교착 상태는 발생하지 않습니다. 하지만 그 외 경우에는 주의를 해서 설계 해야합니다



## Locking을 활용한 동시성 제어

1. 낙관적 락

- 자원에 lock을 직접 걸어서 선점하지 않고, 동시성 문제가 실제로 발생하면 그때가서 처리하는 방식
- 충돌이 발생하면 재시도 or 병합을 통해 해결
- 실제로 lock이 아니라 version을 이용해서 정합성을 맞추는 방법이다. 데이터를 읽을 때 lock을 사용하지 않고 업데이트 시 내가 읽은 version이 맞는 지 충돌 여부를 확인하여 처리한다.

>  충돌할 확률이 적을 때 사용된다.

2. 비관적 락

- 트랜젝션이 시작할 때 s-lock이나 x-lock을 실제로 걸고 시작한다.
- 실제로 데이터에 lock을 걸어서 정합성을 맞추는 방법으로, 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 lock을 걸어버리는 방법이다.
- 데이터를 읽거나 수정하기 전에 lock을 획득하여 다른 사용자의 액세스를 차단하고, lock을 가진 스레드만 접근하도록 제어한다.

> 충돌이 발생할 가능성이 높은 경우 사용되는 동시성 제어 기법이다.

![transaction_slock&xlock](transaction_slock&xlock.png)


3. 분산락 (distributed lock)

- 여러 컴퓨터 또는 프로세스 간에 공유된 자원에 대한 동시 액세스를 제어하기 위해 사용된다.
- 분산 시스템에서 동시성 문제를 해결하기 위해 사용되며, 분산된 서버 또는 클러스터 간의 상호작용이 필요하다.
- 주로 데이터베이스나 메시지 큐 등의 분산 시스템에서 사용된다.
- 대표적인 분산락 기법으로는 ZooKeeper, Redis 등이 있다.

### Redis
Redis는 RedLock이라는 알고리즘을 제안하며 3가지 특성을 보장해야한다고 한다.
- 오직 한 순간에 하나의 작업자만이 락(lock) 을 걸 수 있다.
- 락 이후, 어떠한 문제로 인해 락을 풀지 못하고, 종료된 경우라도 다른 작업자가 락을 획득할 수 있어야합니다.
- Redis 노드가 작동하는한, 모든 작업자는 락을 걸고 해체할 수 있어야합니다.

분산 락을 구현하기 위해 lock에 대한 정보를 Redis에 저장하고 있어야한다. 그리고 분산환경에서 여러대의 서버들은 공통된 Redis를 바라보며, 자신이 공유 자원에 접근할 수 있는지 확인한다.

## 타임 스탬프 (Time Stamp)

- 트랝잭션의 순서대로 시간 스탬프를 지정하여 동시성 제어의 기준으로 사용되는 개념

- 타임 스탬프에는 System 시계 사용법, 논리적 계수 사용법 이 존재.

> System 시계 사용법 : 트랜잭션이 트랜잭션이 시스템에 들어올 때의 system clock 적용
> 논리적 계수 사용법 : 트랜잭션의 시간 스탬프는 그 트랜잭션이 시스템에 들어올 때의 시스템 계수기의 값과 같은 개념

## 적합성 검증(낙관적 검증 기법)

- 트랜잭션이 어떠한 검증도 수행하지 않고, 일단 트랜잭션을 수행하고 종료시 검증을 수행하여 데이터베이스에 반영하는 방법
- 만약 트랜잭션의 길이가 길어 장기적으로 트랜잭션이 진행되었는데 Roll Back 되는 경우 자원 낭비
- 동시 사용 빈도가 낮은 시스템에서 사용

## MVCC(다중버전 동시성 제어 기법)
MVCC(Multi Version Concurreny Control)

> lock은 해당 데이터를 선점한 사용자가 데이터의 lock을 해제하기 전까지는 다른 사용자가 해당 데이터를 컨트롤하는데 제약이 있다. MVCC는 이런 lock의 단점을 보완하기 위한 것이다.

MVCC는 데이터의 업데이트를 할 때, 기존의 내용을 덮어쓰지 않고, 그 데이터의 새로운 버전을 만든다.
쉽게 말해서, A가 D라는 데이터의 D-0버전을 write 할 때, MVCC는 D데이터의 D-1버전을 만들고, 만약 write 도중에 B가 D데이터에 접근하면 D-0버전을 raed 할 수 있도록 해주는 것이다.
때문에 MVCC는 이론상 lock의 개념이 필요없다. (하지만 일부 DBMS들은 MVCC와 lock을 함께 사용한다고 한다.)

MVCC의 특징을 간단하게 짚고 넘어가면
 - lock 기법만 적용된 DBMS보다 훨씬 빠르게 동작
 - 불필요한 데이터(위에서 말한 데이터 버전과 같은)이 많이 쌓여서 주기적으로 이를 정리해줄 별도의 시스템이 필요하다
 - 데이터 버전이 충돌할 가능성이 있음 (이 때문에 MVCC와 lock을 같이 사용하는게 아닐까 싶네요)

MVCC의 불필요한 데이터를 관리하기 위해서는 대표적으로 아래의 방법들이 이용되는 것 같습니다.
 - Vacuum 방식 : 데이터의 버전별 내용을 따로 저장하여 모아두고, 그것을 일정 시점에 삭제한다. (Postgre SQL, CUBRID 등)
    (출처 : postgresql.kr/docs/9.4/routine-vacuuming.html, www.cubrid.org/manual/ko/11.0/sql/transaction.html?#vacuum)
 - Undo Segment 방식 : 데이터의 최신 버전만을 유지하되, old버전은 undo 보관하고, 필요에 따라 undo의 내용을 읽어옴 (Oracle, InnoDB 등)
    (출처 : mysqldba.tistory.com/335 )



1. 데이터에 접근하는 사용자는 접근하는 시점에 데이터베이스 snapshot 을 읽습니다.
이 snapshot 데이터에 대한 변경이 완료(commit) 될 때까지의 변경사항은 다른 데이터베이스 사용자가 볼 수 없습니다.
2. 사용자가 업데이트 하면 이전의 데이터를 덮어 씌우는 것이 아니라 새로운 버전의 데이터를 UNDO 영역에 생성합니다.
3. 이전 버전의 데이터와 비교해서 변경된 내용을 기록합니다.
=> 여러 버전의 데이터를 가지며 현재 실행하고 있는 스케쥴의 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법을 MVCC 라고 합니다 ❗️

MVCC 접근 방식은 트랜잭션의 대기 시간이 존재하지 않음으로 빠르게 동작할 수 있습니다.
또한, 데이터를 읽기 시작할 때 , 다른 트랜잭션이 그 데이터를 삭제하거나 수정해도 영향을 받지 않고 조회 가능합니다.



#### Ref.
- https://this1.tistory.com/entry/MVCC%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC-%EC%A0%95%EB%A6%AC

