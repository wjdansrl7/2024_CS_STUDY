# 웹 어플리케이션의 이해

1. 
- 웹 서버는 정적 리소스를 제공하는 서버
-  WAS는 애플리케이션 로직을 실행하는 서버
WAS는 애플리케이션 로직을 실행하는데 더 특화된 서버, 자바의 경우 서블릿 컨테이너의 기능을 제공하면 대부분 WAS라 칭한다.
2. 
- 미리 정해진 개수의 스레드를 생성해놓고 필요할 때마다 사용하고 반환하는 방식
- 스레드가 미리 생성되어 있어서 스레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답 시간이 빠르다.
- 생성 가능한 스레드의 최대치가 설정돼 있어서 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리 가능

# POJO, PSA, IoC, AOP

1. 
- IoC : 제어의 역전, 프로그램의 제어권이 개발자가 정의한 코드에서 외부 프레임워크 또는 컨테이너로 넘어가는 것을 의미
- DI : 의존성 주입, IoC 컨테이너라는 매개체를 두고 여기에 필요한 모든 모듈들을 등록해둔다. 사용처에서 직접 생성하는 것이 아니라 필요할 때 IoC 컨테이너가 의존성이 있는 모듈들을 주입해주는 방식 

2. AOP : 관점 지향 프로그래밍, 부가 기능을 핵심 기능으로부터 분리함으로써 모듈성을 증가시키는 프로그래밍 패러다임, 핵심 기능의 코드를 수정하지 않으면서 공통 기능의 구현을 추가하는 것

3. PSA : 이식 가능한서비스 추상화, 스프링이 제공하는 다양한 기술을 하나의 추상화된 인터페이스로 제공하여 개발자가 특정 기술에 종속되지 않고 서비스를 사용할 수 있도록 해준다. 유연성과 이식성을 높이고, 다른 기술로의 전환을 쉽게 해준다.

# Proxy

1. 
    - 다른 객체에 대한 대리자 역할을 하는 객체 
    - 클라이언트가 프록시를 통해 대상 객체에 접근하면, 프록시는 대상 객체에 대한 요청을 중간에서 가로채고 필요한 추가 동작을 수행한 뒤에 대상 객체에게 요청을 전달

2. 
    - 클라이언트가 타겟에 접근하는 방법을 제어
    - 타겟에 부가적인 기능을 부여

# @Autowired

1. 생성자 주입(Constructor Injection), 수정자 주입(Setter Injection), 필드 주입(Field Injection)

2. 생성자 주입
    - 불변성 확보   
    - 데이터 누락 시 컴파일 오류가 발생 (final)
    - 순환참조 방지, 발견
    - 테스트에 용이하다.

# Spring vs Spring Boot

1. 
    - **설정의 복잡성:** 스프링에서는 일부 기능을 사용하기 위해 많은 설정을 해주어야 한다. 기능을 더 자세히 제어할 수 있어 장점이 될 수 있지만, 설정이 복잡해지면 관리하기 어렵다.
    - **의존성 관리:** 스프링에서는 프로젝트에 필요한 각종 라이브러리와 의존성을 개발자가 직접 관리한다. 이는 버전 충돌 문제가 발생할 수 있고, 새로운 라이브러리를 추가할 때마다 해당 라이브러리의 설정을 직접 해주어야 해서 번거롭다.
    - **서버 설정:** 스프링에서는 내장 서버를 사용하지 않고 별도의 서버를 설정하고 관리해야 한다.
    - **부가 기능의 미비함:** 스프링부트의 자동 설정은 일부 부가 기능을 제공하지만, 스프링의 경우 이러한 부가 기능들을 직접 설정해주어야 한다. Actuator나 보안과 같은 기능을 추가하려면 수동으로 설정해줘야 한다.
    - **시작 시간:** 스프링부트는 자동 설정을 통해 애플리케이션을 더 빠르게 개발할 수 있지만, 이에 비해 스프링은 설정을 수동으로 해주어야 하므로 초기 설정에 더 많은 시간이 소요될 수 있다.

2. 
    1. **자동 구성 (Auto-Configuration):**
        스프링부트가 클래스 경로에 존재하는 라이브러리 및 설정을 기반으로 애플리케이션의 초기 설정 및 빈을 자동으로 구성하는 기능이다. 이를 통해 개발자는 불필요한 설정 작업을 최소화하고 애플리케이션을 더 쉽게 구성할 수 있다.
        
    2. **Starters:**
        스프링부트는 Starter를 통해 작업에 필요한 의존성을 한데 모은 패키지를 제공한다. 이를 활용하여 라이브러리를 쉽게 추가하고, 버전 충돌 문제를 해결하며, 필요한 설정을 자동으로 처리할 수 있다.
        
    3. **내장 서버(Embedded Server)**
        스프링부트는 기본적으로 Tomcat을 내장 서버로 제공한다. 기존 스프링에서는 외부 서버를 사용해야 했으므로 이를 미리 설치하고 설정해주는 등 복잡한 과정을 거쳤다. 하지만 스프링부트에서는 Tomcat이 내장되어 있으므로 바로 애플리케이션을 실행할 수 있고 배포와 관리를 편하게 해준다.
        
        - Tomcat을 jetty 등의 다른 WAS로 변경 가능하다.
        - 서버가 내장되어 있으므로 war가 아닌 jar파일로 배포할 수 있다. (독립적인 실행, war는 별도의 WS, WAS 필요)
    4. **Actuator:** 
        스프링부트 Actuator는 애플리케이션의 운영 환경에서 사용할 수 있는 다양한 모니터링 및 관리 기능을 제공한다.


# 서블릿

1. HttpServletRequest
2. 
  1) 웹 서버와의 통신 지원
  2) 서블릿 생명주기 관리
  3) 멀티쓰레드 지원 및 관리
  4) 선언적인 보안 관리
  
# Lazy Loading & Eager Loading

1. 즉시 로딩이란 엔티티를 조회할 때 자신과 연관되는 엔티티를 조인(join)을 통해 함께 조회하는 방식
	지연 로딩이란 자신과 연관된 엔티티를 실제로 사용할 때 연관된 엔티티를 조회(SELECT) 하는 방식

2. 프록시 객체

# Interceptor & Filter

1. 서블릿 컨테이너, 스프링 컨테이너
2. preHandle()



# MVC 패턴

1. Model, View, Controller의 약자로, 하나의 어플리케이션이나 프로젝트를 구성할때 구성요소를 세가지 역할로 구분한 패턴이다.

2. 
장점 : 관심사의 분리, 코드의 재사용성과 확장성 증가, 서비스 유지보수 테이스테 유리
한계 : M, V의 의존성을 완전히 분리할 수 없다, Controller의 비중이 높아진다면 `Massive-View-Controller` 현상을 피할 수 없다.

# @Controller @RestController

1. @Controller는 주로 View를 반환하기 위해 쓰인다. 반면에 @RestController JSON 형태로 객체 데이터를 반환한다.

2. @ResponseBody

# Web MVC 요청 처리 과정

1. 사용자의 요청에 맞는 handler(Controller)와 이를 실행할 handlerAdaptor를 찾아주고 실행한 결과를 반환해준다.


2. DispatcherServlet -> HanlderMapping -> HandlerAdaptor -> viewResolver

# Bean(Scope)

1. 
- @ComponentScan, @Component 사용하는 방법
- 빈 설정 파일에 직접 등록하는 방법(@Bean)

2. singleton, prototype, request, session / singleton이 default이다.

# JPA의 캐시

1. 1차 캐시는 어디에 존재하나요?  -> "1차 캐시는 영속성 컨텍스트 내부에 존재"

2. 
1차 캐시는 영속성 컨텍스트 내에 존재해 하나의 요청안에서만 처리가 된다. 하지만 2차캐시는 appliction 범위내에서 동작하기에 Application이 종료될 때까지 캐시가 유지된다.
