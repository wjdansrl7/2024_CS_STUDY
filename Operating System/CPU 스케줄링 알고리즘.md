# CPU 스케줄링 알고리즘

**용어 정리**

- CPU burst - CPU가 코드를 집중적으로 실행하는 상황
- I/O burst : 입출력이 이루어지는 상황

## 1. FCFS(First Come First Served : 선입 선처리) 스케줄링

- **큐에 먼저 도착한 스레드를 먼저 스케줄**
- 스케줄링 파라미터 - **스레드별 큐 도착 시간**
- **비선점 스케줄링** - 먼저 도착한 스레드가 실행을 마쳐야 다음 스레드 실행
- **스레드 우선순위 없음**
- **기아 발생하지 않음**
- 긴 CPU burst를 실행하는 스레드가 CPU를 양도할 때까지 뒤에 대기하거나 늦게 도착한 짧은 스레드들이 오래 대기하여 시스템 전체가 느려지는 호위효과(Convoy Effect)가 나타탄다는 단점이 있다. (CPU와 장치 이용률이 낮아짐)

## 2. SJF(Shortest Job First : 최단 작업 우선) 스케줄링

- **큐에서 예상 실행시간이 가장 짧은 스레드를 우선 선택**
- 스케줄링 파라미터 - **스레드별 예상 실행 시간**
- **비선점 스케줄링** - 선택된 스레드가 실행을 끝낼 때까지 중단시키지 않는다.
- **스레드 우선순위 없음**
- **기아 발생 가능** - 짧은 시간을 가진 스레드가 계속 큐에 도착하면 긴 스레드에 기아 발생
- 짧은 스레드를 먼저 실행하면 대기중인 모든 스레드의 대기 시간이 짧아지므로 평균 대기시간은 최소화 된다. 하지만 실행 시간을 예측할 수 없기 때문에 현실에서는 불가능하다.

## 3. SRTF(Shortest Remaining Time First : 최소 잔여 우선) 스케줄링

- SJF의 선점 스케줄링 버전, **남은 실행시간이 가장 짧은 스레드를 우선 스케줄**, 더 짧은 스레드가 들어오면 멈추고 도착한 스레드 실행
- 스케줄링 파라미터 - **스레드별 예상 실행 시간**
- **선점 스케줄링** - 더 짧은게 들어오면 중단하고 실행하기 때문에
- **스레드 우선순위 없음**
- **기아 발생 가능** - 짧은 실행 시간을 가진 스레드가 연속적으로 큐에 들어오면 긴 스레드는 실행되기 어렵다.
- SJF와 마찬가지로 평균 대기 시간을 최소화할 수 있지만 실현이 어렵다.

## 4. RR(Round-Robin) 스케줄링

- 스레드들에게 **공평한 기회**를 주기 위해 큐에 대기중인 스레드들을 **타임 슬라이스 주기**로 돌아가면서 선택한다. 스레드 실행 후 타임 슬라이스가 지나면 커널에 의해 강제로 중단된 후 큐 끝에 삽입된다. (타임 슬라이스는 상황에 따라 조정된다.)
- 스케줄링 파라미터 - **타임 슬라이스**
- **선점 스케줄링** - 타임 슬라이스가 지나면 강제로 중단시키고 새 스레드를 실행하기 때문이다.
- **스레드 우선순위  없음**
- **기아 발생하지 않음**
- **공평하고 기아가 없으며 구현이 쉽다는 장점이 있다**. 하지만 잦은 스케줄링으로 인해 스케줄링과 컨텍스트 스위칭에 소요되는 시간이 크다는 단점이 있다. 타임 슬라이스가 작을수록 스케줄링이 빈번해져 성능이 저하된다. 타임 슬라이스가 커질수록 FCFS에, 작아질수록 SJF, SRTF에 가깝다.

## 5. Priority 스케줄링

- **우선순위에 따라 스레드를 실행한다.** 스레드마다 고정 우선순위가 정해져있는 상황에서, 큐에서 가장 높은 우선순위의 스레드를 선택한다.
- 스케줄링 파라미터 - **스레드들의 우선순위 값**
- **선점 / 비선점 모두 가능** - 더 높은 우선순위가 오면 중단시키거나 안하거나 둘다 가능하다.
- 스레드 우선순위  - **스레드마다 고정 우선순위**
- **기아 발생 가능** - 지속적으로 높은 우선순위의 스레드만 큐에 도착하는 경우 기아가 발생할 수 있다. 큐의 대기 시간에 비례하여 일시적으로 우선순위를 높이는 에이징 기법으로 기아 해결 가능

## 6. MLQ(Multi-level Queue) 스케줄링

- **스레드들은 n개의 우선순위 레벨로 구분하고 레벨이 높은 스레드를 우선 처리한다.**
- 스레드를 우선순위에 따라 큐에 삽입한다. 스레드는 도착한 순서대로 큐에 삽입되며 **다른 큐로 이동할 수 없다.** 가장 높은 레벨의 큐에서 맨 앞에 있는 스레드를 선택하며, 높은 레벨의 큐가 비어 있을 때 그 아래 레벨의 큐에서 스레드를 선택한다. 큐마다 별로의 큐 스케줄러를 둘 수 있는데, 큐앞에 배치하거나 MLQ 스케줄러가 큐에서 하나를 선택할 때 호출되도록 배치하여, CPU 사용 시간 등 다른 지표를 이용하여 큐 내 스레드를 스케줄링할 수도 있다.
- 스케줄링 파라미터 - **스레드 우선순위**
- **선점 / 비선점 모두 가능**
- 스레드 우선순위 - **고정 우선순위(n 레벨 중 하나)**
- **기아 발생 가능** - 지속적으로 높은 우선순위의 스레드만 큐에 도착할 때

## 7. MLFQ(Multi-level Feedback Queue) 스케줄링

- 스레드를 다른 큐로 이동할 수 없다는 MLQ의 특성으로 인해 발생하는 기아를 해결하기 위해 스레드를 다른 레벨의 큐로 이동시킬 수 있도록 개선
- **CPU burst가 짧은 스레드나 I/O 작없이 많은 스레드, 혹은 대화식 스레드를 우선 실행시켜 스레드의 평균 대기시간을 줄이고 사용자의 응답시간을 짧게하여 스레드에 기아가 발생하지 않도록 한다.**
- 우선순위로 구분된 n개의 큐를 둔다. 스레드는 우선순위가 없고 도착 할 때 가장 높은 레벨의 큐에 삽입된다. 높은 레벨의 큐를 먼저 스케줄링하며, 높은 레벨의 큐가 비어 있을 때만 아래 레벨의 큐에서 스케줄링한다. MLFQ는 큐마다 별도의 스케줄링 정책을 사용할 수 있으며 RR이 가장 무난하게 쓰인다. 큐마다 타임 슬라이스를 다르게 설정하는데 낮은 우선순위 일수록 타임 슬라이스가 크게 설정된다. 큐의 타임 슬라이스를 넘어가면 강제 중단되어 아래 레벨 큐로 이동된다. 타임 슬라이스 전에 스레드의 CPU burst가 끝나면 스레드는 동일한 큐에 다시 삽입된다. 스레드가 I/O를 요청하면 해당 큐에서 나오지만, I/O 작업이 끝나면 동일한 큐로 삽입된다. **큐에서 대기하는 시간이 오래되면 한 레벨 위의 큐로 이동시킨다.** 최하위 레벨 큐는 주로 FCFS나 긴 타임 슬라이스 RR로 스케줄링 된다.
- 스케줄링 파라미터 - **큐의 개수, 각 큐의 스케줄링 알고리즘, 우선순위 격하 시점(각 큐의 타임 슬라이스), 우선순위 격상 시점(기아를 막기위해 한 레벨 높은 큐로 이동 시키기 위한 큐 대기 시간 최대치)**
- **선점 스케줄링** - 타임 슬라이스 초과시 중단, 구현에 따라 달라질 수 있다.
- **스레드 우선순위 없음**
- **기아 발생하지 않음**
- CPU burst가 짧거나 입출력이 빈번한 스레드, 혹은 대화식 스레드에게 높은 우선순위를 주어 응답 시간을 빨리하고 평균 대기 시간을 줄인다. 또한 기아를 막을 수 있고, 큐의 개수나 타임 슬라이스 값 등 스케줄링 파라미터를 조절하여 대상 시스템에 적합하게 구현할 수 있는 유연성이 뛰어나지만, 알고리즘이 복잡하여 CPU의 오버헤드가 증가되는 단점도 있다.

 

### ref)

황기태 교수님의 명품 운영체제

https://sihyung92.oopy.io/os/5
